# controllerGen.py
# Generates ESM controller files for your MERN backend.
# Place this file in /controllers and run:  python3 controllerGen.py

from pathlib import Path
from textwrap import dedent

BASE = Path(__file__).parent.resolve()

def write(path: Path, content: str):
    path.write_text(content.strip() + "\n", encoding="utf-8")
    print(f"✔ wrote {path.relative_to(BASE)}")

HDR = "// Auto-generated by controllerGen.py — feel free to edit.\n"

def mk_common_list_helpers():
    return dedent("""
        // Common helpers
        const parsePaging = (req) => {
          const page = Math.max(parseInt(req.query.page || "1", 10), 1);
          const limit = Math.min(Math.max(parseInt(req.query.limit || "20", 10), 1), 100);
          const skip = (page - 1) * limit;
          return { page, limit, skip };
        };

        const ok = (res, data, meta) => {
          const body = { success: true, data };
          if (meta) body.meta = meta;
          return res.status(200).json(body);
        };

        const created = (res, data) => res.status(201).json({ success: true, data });
        const noContent = (res) => res.status(204).json({ success: true });
    """)

# ---------- INDIVIDUAL CONTROLLERS ----------

def auth_controller():
    return HDR + dedent("""
        import User from "../models/User.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        const setAuthCookie = (res, token) => {
          res.cookie("accessToken", token, {
            httpOnly: true,
            secure: process.env.NODE_ENV === "production",
            sameSite: "Strict",
            maxAge: 15 * 60 * 1000,
          });
        };

        // @desc Register user
        // @route POST /api/v1/auth/register
        // @access Public
        export const register = asyncHandler(async (req, res) => {
          const { name, email, phone, password, role } = req.body;
          const user = await User.create({ name, email, phone, password, role });
          const token = user.getSignedJwtToken();
          setAuthCookie(res, token);
          return res.status(201).json({
            success: true,
            message: "User registered successfully",
            data: {
              user: { id: user._id, name: user.name, email: user.email, role: user.role }
            }
          });
        });

        // @desc Login
        // @route POST /api/v1/auth/login
        // @access Public
        export const login = asyncHandler(async (req, res) => {
          const { email, password } = req.body;
          const user = await User.findOne({ email }).select("+password");
          if (!user || !(await user.matchPassword(password))) {
            return res.status(401).json({ success: false, message: "Invalid credentials" });
          }
          const token = user.getSignedJwtToken();
          setAuthCookie(res, token);
          return res.status(200).json({
            success: true,
            message: "Logged in",
            data: { user: { id: user._id, name: user.name, email: user.email, role: user.role } }
          });
        });

        // @desc Get profile
        // @route GET /api/v1/auth/me
        // @access Private
        export const getMe = asyncHandler(async (req, res) => {
          const user = await User.findById(req.user.id).lean();
          return res.status(200).json({ success: true, data: user });
        });
    """)

def pg_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        import Pg from "../models/Pg.js";
        import Room from "../models/Room.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        // CRUD
        export const getPgs = asyncHandler(async (req, res) => {
          const { page, limit, skip } = parsePaging(req);
          const q = req.query.q?.trim();
          const filter = q ? { pgName: { $regex: q, $options: "i" } } : {};
          const [items, total] = await Promise.all([
            Pg.find(filter).skip(skip).limit(limit).lean(),
            Pg.countDocuments(filter)
          ]);
          return ok(res, items, { page, limit, total, hasNext: skip + items.length < total });
        });

        export const getPg = asyncHandler(async (req, res) => {
          const item = await Pg.findById(req.params.id).lean();
          return ok(res, item);
        });

        export const createPg = asyncHandler(async (req, res) => {
          const item = await Pg.create(req.body);
          return created(res, item);
        });

        export const updatePg = asyncHandler(async (req, res) => {
          const item = await Pg.findByIdAndUpdate(req.params.id, req.body, { new: true }).lean();
          return ok(res, item);
        });

        export const deletePg = asyncHandler(async (req, res) => {
          await Pg.findByIdAndDelete(req.params.id);
          return noContent(res);
        });

        // Nested: rooms under PG
        export const getRoomsByPg = asyncHandler(async (req, res) => {
          const items = await Room.find({ pgId: req.params.pgId }).lean();
          return ok(res, items);
        });

        export const createRoomForPg = asyncHandler(async (req, res) => {
          const payload = { ...req.body, pgId: req.params.pgId };
          const room = await Room.create(payload);
          return created(res, room);
        });
    """)

def room_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        import Room from "../models/Room.js";
        import Bed from "../models/Bed.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        export const getRooms = asyncHandler(async (req, res) => {
          const { page, limit, skip } = parsePaging(req);
          const filter = {};
          if (req.query.pgId) filter.pgId = req.query.pgId;
          if (req.query.status) filter.status = req.query.status;
          if (req.query.floor) filter.floor = Number(req.query.floor);
          const [items, total] = await Promise.all([
            Room.find(filter).skip(skip).limit(limit).lean(),
            Room.countDocuments(filter)
          ]);
          return ok(res, items, { page, limit, total, hasNext: skip + items.length < total });
        });

        export const getRoom = asyncHandler(async (req, res) => {
          const item = await Room.findById(req.params.id).lean();
          return ok(res, item);
        });

        export const createRoom = asyncHandler(async (req, res) => {
          const room = await Room.create(req.body);
          return created(res, room);
        });

        export const updateRoom = asyncHandler(async (req, res) => {
          const item = await Room.findByIdAndUpdate(req.params.id, req.body, { new: true }).lean();
          return ok(res, item);
        });

        export const deleteRoom = asyncHandler(async (req, res) => {
          await Room.findByIdAndDelete(req.params.id);
          return noContent(res);
        });

        // Nested beds under room
        export const getBedsByRoom = asyncHandler(async (req, res) => {
          const items = await Bed.find({ roomId: req.params.id }).lean();
          return ok(res, items);
        });

        export const createBedForRoom = asyncHandler(async (req, res) => {
          const bed = await Bed.create({ ...req.body, roomId: req.params.id });
          return created(res, bed);
        });
    """)

def bed_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        import Bed from "../models/Bed.js";
        import Occupancy from "../models/Occupancy.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        export const getBeds = asyncHandler(async (req, res) => {
          const { page, limit, skip } = parsePaging(req);
          const filter = {};
          if (req.query.roomId) filter.roomId = req.query.roomId;
          if (req.query.pgId) filter.pgId = req.query.pgId; // only if denormalized; else ignore
          if (req.query.isOccupied !== undefined) filter.isOccupied = req.query.isOccupied === "true";
          const [items, total] = await Promise.all([
            Bed.find(filter).skip(skip).limit(limit).lean(),
            Bed.countDocuments(filter)
          ]);
          return ok(res, items, { page, limit, total, hasNext: skip + items.length < total });
        });

        export const getBed = asyncHandler(async (req, res) => {
          const item = await Bed.findById(req.params.id).lean();
          return ok(res, item);
        });

        export const createBed = asyncHandler(async (req, res) => {
          const bed = await Bed.create(req.body);
          return created(res, bed);
        });

        export const updateBed = asyncHandler(async (req, res) => {
          const item = await Bed.findByIdAndUpdate(req.params.id, req.body, { new: true }).lean();
          return ok(res, item);
        });

        export const deleteBed = asyncHandler(async (req, res) => {
          await Bed.findByIdAndDelete(req.params.id);
          return noContent(res);
        });

        // Availability helper
        export const getBedAvailability = asyncHandler(async (req, res) => {
          const { from, to } = req.query;
          const filter = { bedId: req.params.id };
          if (from && to) {
            filter.$or = [
              { start_date: { $lt: new Date(to) }, end_date: { $gt: new Date(from) } },
              { start_date: { $lte: new Date(to) }, end_date: null }
            ];
          }
          const occs = await Occupancy.find(filter).lean();
          return ok(res, { occupancies: occs });
        });
    """)

def tenant_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        import Tenant from "../models/Tenant.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        export const getTenants = asyncHandler(async (req, res) => {
          const { page, limit, skip } = parsePaging(req);
          const filter = {};
          if (req.query.active !== undefined) filter.active = req.query.active === "true";
          if (req.query.email) filter.email = req.query.email.toLowerCase();
          if (req.query.mobile) filter.mobile = req.query.mobile;
          if (req.query.q) {
            filter.$or = [
              { name: { $regex: req.query.q, $options: "i" } },
              { email: { $regex: req.query.q, $options: "i" } },
              { mobile: { $regex: req.query.q, $options: "i" } }
            ];
          }
          const [items, total] = await Promise.all([
            Tenant.find(filter).skip(skip).limit(limit).lean(),
            Tenant.countDocuments(filter)
          ]);
          return ok(res, items, { page, limit, total, hasNext: skip + items.length < total });
        });

        export const getTenant = asyncHandler(async (req, res) => {
          const item = await Tenant.findById(req.params.id).lean();
          return ok(res, item);
        });

        export const createTenant = asyncHandler(async (req, res) => {
          const t = await Tenant.create(req.body);
          return created(res, t);
        });

        export const updateTenant = asyncHandler(async (req, res) => {
          const t = await Tenant.findByIdAndUpdate(req.params.id, req.body, { new: true }).lean();
          return ok(res, t);
        });

        export const deleteTenant = asyncHandler(async (req, res) => {
          await Tenant.findByIdAndDelete(req.params.id);
          return noContent(res);
        });
    """)

def occupancy_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        import Occupancy from "../models/Occupancy.js";
        import Bed from "../models/Bed.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        export const getOccupancies = asyncHandler(async (req, res) => {
          const { page, limit, skip } = parsePaging(req);
          const filter = {};
          if (req.query.tenantId) filter.tenantId = req.query.tenantId;
          if (req.query.bedId) filter.bedId = req.query.bedId;
          if (req.query.active !== undefined) {
            filter.end_date = req.query.active === "true" ? null : { $ne: null };
          }
          if (req.query.from && req.query.to) {
            filter.start_date = { $lt: new Date(req.query.to) };
            filter.$or = [{ end_date: null }, { end_date: { $gt: new Date(req.query.from) } }];
          }
          const [items, total] = await Promise.all([
            Occupancy.find(filter).skip(skip).limit(limit).lean(),
            Occupancy.countDocuments(filter)
          ]);
          return ok(res, items, { page, limit, total, hasNext: skip + items.length < total });
        });

        export const getOccupancy = asyncHandler(async (req, res) => {
          const item = await Occupancy.findById(req.params.id).lean();
          return ok(res, item);
        });

        export const createOccupancy = asyncHandler(async (req, res) => {
          // Optional: enforce one active occupancy per bed
          if (!req.body.end_date) {
            const active = await Occupancy.exists({ bedId: req.body.bedId, end_date: null });
            if (active) return res.status(409).json({ success: false, message: "Bed already occupied" });
          }
          const occ = await Occupancy.create(req.body);
          // OPTIONAL: update Bed.isOccupied flag
          await Bed.updateOne({ _id: occ.bedId }, { $set: { isOccupied: true } });
          return created(res, occ);
        });

        export const updateOccupancy = asyncHandler(async (req, res) => {
          const occ = await Occupancy.findByIdAndUpdate(req.params.id, req.body, { new: true }).lean();
          return ok(res, occ);
        });

        export const deleteOccupancy = asyncHandler(async (req, res) => {
          await Occupancy.findByIdAndDelete(req.params.id);
          return noContent(res);
        });

        // Actions
        export const closeOccupancy = asyncHandler(async (req, res) => {
          const { end_date } = req.body;
          const occ = await Occupancy.findByIdAndUpdate(
            req.params.id,
            { $set: { end_date: end_date || new Date(), status: "moved_out" } },
            { new: true }
          ).lean();
          // OPTIONAL: recompute Bed.isOccupied
          const stillActive = await Occupancy.exists({ bedId: occ.bedId, end_date: null });
          await Bed.updateOne({ _id: occ.bedId }, { $set: { isOccupied: !!stillActive } });
          return ok(res, occ);
        });

        export const transferOccupancy = asyncHandler(async (req, res) => {
          const { toBedId, transfer_date } = req.body;
          const closed = await Occupancy.findByIdAndUpdate(
            req.params.id,
            { $set: { end_date: transfer_date || new Date(), status: "moved_out" } },
            { new: true }
          ).lean();
          await Bed.updateOne({ _id: closed.bedId }, { $set: { isOccupied: false } });
          const reopened = await Occupancy.create({
            bedId: toBedId,
            tenantId: closed.tenantId,
            start_date: transfer_date || new Date(),
            status: "active"
          });
          await Bed.updateOne({ _id: toBedId }, { $set: { isOccupied: true } });
          return ok(res, { from: closed, to: reopened });
        });
    """)

def bill_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        import Bill from "../models/Bill.js";
        import Transaction from "../models/Transaction.js";
        import Bed from "../models/Bed.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        // GET /bills
        export const getBills = asyncHandler(async (req, res) => {
          const { page, limit, skip } = parsePaging(req);
          const filter = {};
          if (req.query.tenantId) filter.tenantId = req.query.tenantId;
          if (req.query.bedId) filter.bedId = req.query.bedId;
          if (req.query.status) filter.status = req.query.status;
          if (req.query.from && req.query.to) {
            filter.period_start = { $lt: new Date(req.query.to) };
            filter.period_end = { $gt: new Date(req.query.from) };
          }
          const [items, total] = await Promise.all([
            Bill.find(filter).skip(skip).limit(limit).lean(),
            Bill.countDocuments(filter)
          ]);
          return ok(res, items, { page, limit, total, hasNext: skip + items.length < total });
        });

        export const getBill = asyncHandler(async (req, res) => {
          const item = await Bill.findById(req.params.id).lean();
          return ok(res, item);
        });

        export const createBill = asyncHandler(async (req, res) => {
          const bill = await Bill.create(req.body);
          return created(res, bill);
        });

        export const updateBill = asyncHandler(async (req, res) => {
          const bill = await Bill.findByIdAndUpdate(req.params.id, req.body, { new: true }).lean();
          return ok(res, bill);
        });

        export const deleteBill = asyncHandler(async (req, res) => {
          await Bill.findByIdAndDelete(req.params.id);
          return noContent(res);
        });

        // Helpers
        const computePaidForBill = async (billId) => {
          const agg = await Transaction.aggregate([
            { $match: { billId } },
            { $group: { _id: "$billId", paid: { $sum: "$amount" } } }
          ]);
          return agg[0]?.paid || 0;
        };

        const deriveStatus = (amount, paid) => {
          if (paid <= 0) return "pending";
          if (paid < amount) return "partial";
          return "paid";
        };

        // GET /bills/:id/summary
        export const getBillSummary = asyncHandler(async (req, res) => {
          const bill = await Bill.findById(req.params.id).lean();
          if (!bill) return res.status(404).json({ success: false, message: "Bill not found" });
          const paid = await computePaidForBill(bill._id);
          const balance = Number((bill.amount - paid).toFixed(2));
          return ok(res, {
            ...bill,
            summary: { amount: bill.amount, paid, balance, status: deriveStatus(bill.amount, paid) }
          });
        });

        // POST /bills/:id/recalculate  (basic proration using bed.defaultCost)
        export const recalculateBill = asyncHandler(async (req, res) => {
          const bill = await Bill.findById(req.params.id).lean();
          if (!bill) return res.status(404).json({ success: false, message: "Bill not found" });

          const bed = await Bed.findById(bill.bedId).lean();
          const cost = bed?.defaultCost || bill.amount;

          const start = new Date(bill.period_start);
          const end = new Date(bill.period_end);
          const msDay = 24*60*60*1000;
          const days = Math.max(1, Math.ceil((end - start) / msDay));
          const monthStart = new Date(start.getFullYear(), start.getMonth(), 1);
          const nextMonth = new Date(start.getFullYear(), start.getMonth()+1, 1);
          const daysInMonth = Math.round((nextMonth - monthStart) / msDay);

          const newAmount = Number(((cost / daysInMonth) * days).toFixed(2));
          const updated = await Bill.findByIdAndUpdate(req.params.id, { $set: { amount: newAmount } }, { new: true }).lean();
          return ok(res, updated);
        });

        // POST /bills/:id/mark-paid  (usually you won’t need this if deriving from transactions)
        export const markBillPaid = asyncHandler(async (req, res) => {
          const bill = await Bill.findById(req.params.id).lean();
          if (!bill) return res.status(404).json({ success: false, message: "Bill not found" });
          const paid = await computePaidForBill(bill._id);
          const status = deriveStatus(bill.amount, paid);
          const updated = await Bill.findByIdAndUpdate(req.params.id, { $set: { status } }, { new: true }).lean();
          return ok(res, updated);
        });

        // Tenant helpers
        export const getTenantBills = asyncHandler(async (req, res) => {
          const items = await Bill.find({ tenantId: req.params.id }).lean();
          return ok(res, items);
        });
    """)

def transaction_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        import Transaction from "../models/Transaction.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        export const getTransactions = asyncHandler(async (req, res) => {
          const { page, limit, skip } = parsePaging(req);
          const filter = {};
          if (req.query.billId) filter.billId = req.query.billId;
          if (req.query.method) filter.method = req.query.method;
          if (req.query.from && req.query.to) {
            filter.dateTime = { $gte: new Date(req.query.from), $lte: new Date(req.query.to) };
          }
          const [items, total] = await Promise.all([
            Transaction.find(filter).skip(skip).limit(limit).lean(),
            Transaction.countDocuments(filter)
          ]);
          return ok(res, items, { page, limit, total, hasNext: skip + items.length < total });
        });

        export const getTransaction = asyncHandler(async (req, res) => {
          const item = await Transaction.findById(req.params.id).lean();
          return ok(res, item);
        });

        export const createTransaction = asyncHandler(async (req, res) => {
          const txn = await Transaction.create(req.body);
          return created(res, txn);
        });

        export const updateTransaction = asyncHandler(async (req, res) => {
          const txn = await Transaction.findByIdAndUpdate(req.params.id, req.body, { new: true }).lean();
          return ok(res, txn);
        });

        export const deleteTransaction = asyncHandler(async (req, res) => {
          await Transaction.findByIdAndDelete(req.params.id);
          return noContent(res);
        });

        // Tenant helper
        export const getTenantTransactions = asyncHandler(async (req, res) => {
          const items = await Transaction.find({ tenantId: req.params.id }).lean();
          return ok(res, items);
        });
    """)

def document_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        import Document from "../models/Document.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        export const getDocuments = asyncHandler(async (req, res) => {
          const { page, limit, skip } = parsePaging(req);
          const filter = {};
          if (req.query.type) filter.type = req.query.type;
          if (req.query.q) filter.file_name = { $regex: req.query.q, $options: "i" };
          const [items, total] = await Promise.all([
            Document.find(filter).skip(skip).limit(limit).lean(),
            Document.countDocuments(filter)
          ]);
          return ok(res, items, { page, limit, total, hasNext: skip + items.length < total });
        });

        export const getDocument = asyncHandler(async (req, res) => {
          const item = await Document.findById(req.params.id).lean();
          return ok(res, item);
        });

        export const createDocument = asyncHandler(async (req, res) => {
          const doc = await Document.create(req.body);
          return created(res, doc);
        });

        export const updateDocument = asyncHandler(async (req, res) => {
          const doc = await Document.findByIdAndUpdate(req.params.id, req.body, { new: true }).lean();
          return ok(res, doc);
        });

        export const deleteDocument = asyncHandler(async (req, res) => {
          await Document.findByIdAndDelete(req.params.id);
          return noContent(res);
        });
    """)

def tenant_document_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        import TenantDocument from "../models/TenantDocument.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        export const getTenantDocuments = asyncHandler(async (req, res) => {
          const filter = {};
          if (req.query.tenantId) filter.tenantId = req.query.tenantId;
          if (req.query.type) filter.type = req.query.type;
          const items = await TenantDocument.find(filter).lean();
          return ok(res, items);
        });

        export const linkTenantDocument = asyncHandler(async (req, res) => {
          const link = await TenantDocument.create(req.body);
          return created(res, link);
        });

        export const unlinkTenantDocument = asyncHandler(async (req, res) => {
          const { tenantId, docId } = req.params;
          await TenantDocument.findOneAndDelete({ tenantId, docId });
          return noContent(res);
        });
    """)

def billing_run_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        // This is a stub; wire to your billing service logic.
        import { asyncHandler } from "../middlewares/errorHandler.js";

        export const createBillingRun = asyncHandler(async (req, res) => {
          // TODO: generate bills based on occupancies & period in req.body
          return created(res, { runId: "stub", createdBills: [] });
        });

        export const previewBillingRun = asyncHandler(async (req, res) => {
          return ok(res, { preview: true, wouldCreate: [] });
        });

        export const getBillingRun = asyncHandler(async (req, res) => {
          return ok(res, { id: req.params.id, status: "done", stats: {} });
        });
    """)

def report_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        import Bill from "../models/Bill.js";
        import Transaction from "../models/Transaction.js";
        import Occupancy from "../models/Occupancy.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        export const arrearsReport = asyncHandler(async (req, res) => {
          const asOf = req.query.asOf ? new Date(req.query.asOf) : new Date();
          const bills = await Bill.aggregate([
            { $match: { period_start: { $lte: asOf } } },
            { $lookup: { from: "transactions", localField: "_id", foreignField: "billId", as: "txns" } },
            { $addFields: { paid: { $sum: "$txns.amount" }, balance: { $subtract: ["$amount", { $sum: "$txns.amount" }] } } },
            { $project: { txns: 0 } },
            { $match: { balance: { $gt: 0 } } }
          ]);
          return ok(res, bills);
        });

        export const occupancyRateReport = asyncHandler(async (req, res) => {
          // Minimal stub; implement proper date-bucketed occupancy % later
          const total = await Occupancy.countDocuments({});
          return ok(res, { totalOccupancies: total });
        });

        export const revenueReport = asyncHandler(async (req, res) => {
          const from = req.query.from ? new Date(req.query.from) : new Date("1970-01-01");
          const to = req.query.to ? new Date(req.query.to) : new Date();
          const tx = await Transaction.aggregate([
            { $match: { dateTime: { $gte: from, $lte: to } } },
            { $group: { _id: null, revenue: { $sum: "$amount" } } }
          ]);
          return ok(res, { revenue: tx[0]?.revenue || 0 });
        });
    """)

def dashboard_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        import Bill from "../models/Bill.js";
        import Transaction from "../models/Transaction.js";
        import Occupancy from "../models/Occupancy.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        export const tenantDashboard = asyncHandler(async (req, res) => {
          const tenantId = req.params.tenantId;
          const [bills, txns, occ] = await Promise.all([
            Bill.find({ tenantId }).sort({ createdAt: -1 }).limit(10).lean(),
            Transaction.find({ tenantId }).sort({ dateTime: -1 }).limit(10).lean(),
            Occupancy.find({ tenantId, end_date: null }).lean()
          ]);
          return ok(res, { bills, txns, activeOccupancies: occ });
        });
    """)

def search_controller():
    return HDR + mk_common_list_helpers() + dedent("""
        import Tenant from "../models/Tenant.js";
        import Room from "../models/Room.js";
        import Bed from "../models/Bed.js";
        import Bill from "../models/Bill.js";
        import { asyncHandler } from "../middlewares/errorHandler.js";

        export const globalSearch = asyncHandler(async (req, res) => {
          const q = (req.query.q || "").trim();
          if (!q) return ok(res, { tenants: [], rooms: [], beds: [], bills: [] });
          const rx = new RegExp(q, "i");
          const [tenants, rooms, beds, bills] = await Promise.all([
            Tenant.find({ $or: [{ name: rx }, { email: rx }, { mobile: rx }] }).limit(10).lean(),
            Room.find({ $or: [{ no: rx }] }).limit(10).lean(),
            Bed.find({ $or: [{ bedNo: rx }] }).limit(10).lean(),
            Bill.find({ remarks: rx }).limit(10).lean(),
          ]);
          return ok(res, { tenants, rooms, beds, bills });
        });
    """)

def index_readme():
    return dedent("""
        # Generated controllers

        These stubs expect:
        - `asyncHandler` in `../middlewares/errorHandler.js`
        - Mongoose models: Pg, Room, Bed, Tenant, Occupancy, Bill, Transaction, Document, TenantDocument, User

        All responses are `{ success, data, meta? }`. Edit freely to fit your business rules.
    """)

FILES = {
    "authController.js": auth_controller(),
    "pgController.js": pg_controller(),
    "roomController.js": room_controller(),
    "bedController.js": bed_controller(),
    "tenantController.js": tenant_controller(),
    "occupancyController.js": occupancy_controller(),
    "billController.js": bill_controller(),
    "transactionController.js": transaction_controller(),
    "documentController.js": document_controller(),
    "tenantDocumentController.js": tenant_document_controller(),
    "billingRunController.js": billing_run_controller(),
    "reportController.js": report_controller(),
    "dashboardController.js": dashboard_controller(),
    "searchController.js": search_controller(),
    "CONTROLLERS_README.md": index_readme(),
}

def main():
    BASE.mkdir(parents=True, exist_ok=True)
    for fname, content in FILES.items():
        write(BASE / fname, content)

if __name__ == "__main__":
    main()
